{
  "page_type": "architecture",
  "page_title": "전체 시스템 아키텍처 및 주요 기능에서 사용되는 디자인 패턴 (아키텍처 다이어그램 및 플로우 다이어그램 포함)",
  "content": "# 전체 시스템 아키텍처 & 디자인 패턴\n\n## 시스템 아키텍처 개요\n\n### 아키텍처 스타일\n이 프로젝트는 하이브리드 아키텍처 스타일을 사용합니다. 주요 구성 요소들은 모듈화되어 있으며, 데이터 처리 파이프라인과 같은 특정 기능에는 파이프라인 패턴이 적용되었습니다. 또한, Tree-sitter 파서와 같은 외부 라이브러리와의 통합은 어댑터 패턴을 통해 이루어집니다. 저장소(PostgreSQL + pgvector)와 상호 작용하는 부분은 저장소 패턴을 활용합니다.\n\n### 주요 아키텍처 결정\n1. **Tree-sitter 사용:** 소스 코드의 구조적 청킹을 위해 Tree-sitter를 선택했습니다. 이는 정확하고 언어별 파싱을 가능하게 하며, 기존 TypeScript 기반 시스템과의 호환성을 유지합니다.\n2. **pgvector 사용:** 벡터 임베딩을 저장하고 유사도 검색을 수행하기 위해 PostgreSQL과 pgvector 확장을 선택했습니다. 이는 효율적인 벡터 검색 성능과 기존 PostgreSQL 인프라와의 통합 용이성을 제공합니다.\n3. **모듈화된 구조:** 코드 청킹, 임베딩, 데이터베이스 상호 작용과 같은 기능을 별도의 모듈로 분리하여 유지보수성과 확장성을 높였습니다.\n4. **비동기 처리:** `asyncio`를 사용하여 파일 처리 및 데이터베이스 상호 작용과 같은 I/O 바운드 작업을 비동기적으로 처리하여 성능을 향상시켰습니다.\n\n### 구성 요소 개요\n- **`core`:** 핵심 기능을 담당하는 모듈입니다.\n    - **`index.py`:** 주요 데이터 타입 정의 (예: `PathAndCacheKey`).\n    - **`embeddings`:** 임베딩 생성 및 관리 관련 로직을 포함합니다 (`embeddings_provider.py`, `simple_embeddings.py`).\n    - **`indexing`:** 코드 청킹 및 인덱싱 로직을 포함합니다 (`chunk/`, `lance_db_index.py`, `pgvector_index.py`).\n    - **`llm`:** 토큰 카운팅과 같은 LLM 관련 유틸리티를 제공합니다 (`count_tokens.py`).\n    - **`util`:** Tree-sitter 파싱 및 URI 처리와 같은 유틸리티 함수를 제공합니다 (`tree_sitter.py`, `uri.py`).\n- **`vendor`:** Tree-sitter 파서 소스 코드를 포함합니다 (예: `tree-sitter-python/`, `tree-sitter-javascript/`).\n- **`main.py`:** 메인 실행 파일로, 디렉토리 인덱싱 기능을 제공합니다.\n- **`setup_vendor.py`:** Tree-sitter 파서 소스를 다운로드하는 스크립트입니다.\n- **`build_parsers.py`:** 다운로드된 Tree-sitter 파서 소스를 컴파일하여 `.so` 파일을 생성하는 스크립트입니다.\n- **`db_test.py`:** 데이터베이스 연결 및 검색을 테스트하는 스크립트입니다.\n- **`drop_table.py`:** 데이터베이스 테이블을 삭제하는 스크립트입니다.\n\n## 아키텍처 다이어그램\n\n### 고수준 아키텍처\n```mermaid\ngraph LR\n    A[소스 코드] --> B(Tree-sitter 파서);\n    B --> C{AST 생성};\n    C --> D[코드 청킹];\n    D --> E[메타데이터 추출];\n    E --> F(임베딩 생성);\n    F --> G[PostgreSQL + pgvector];\n    H[쿼리] --> G;\n    style A fill:#f9f,stroke:#333,stroke-width:2px\n    style G fill:#ccf,stroke:#333,stroke-width:2px\n```\n\n### 구성 요소 상호 작용\n```mermaid\nsequenceDiagram\nparticipant Main as main.py\nparticipant PgIndex as PgVectorIndex\nparticipant Embeddings as EmbeddingsProvider\nparticipant TreeSitterUtil as tree_sitter.py\nparticipant DB as PostgreSQL\nMain->>PgIndex: index.get_chunks(file_item, code)\nPgIndex->>TreeSitterUtil: parse_code(code, language)\nTreeSitterUtil->>TreeSitterUtil: Tree-sitter 파싱\nTreeSitterUtil-->>PgIndex: AST 반환\nPgIndex->>PgIndex: getSmartCollapsedChunks(AST)\nPgIndex->>Embeddings: get_embeddings(chunks)\nEmbeddings->>Embeddings: 임베딩 생성\nEmbeddings-->>PgIndex: 임베딩 반환\nPgIndex->>DB: insert_chunks(chunks, embeddings)\nDB-->>PgIndex: 성공\nPgIndex-->>Main: 완료\n```\n\n## 디자인 패턴\n\n### 패턴 1: 저장소 (Repository)\n- **타입**: 구조적\n- **위치**: `core/indexing/pgvector_index.py`\n- **목적**: 데이터 액세스 로직을 캡슐화하여 애플리케이션 로직과 데이터 저장소 간의 의존성을 줄입니다.\n- **구현**: `PgVectorIndex` 클래스는 데이터베이스 상호 작용을 처리하는 저장소 역할을 합니다. `insert_chunks`, `retrieve`와 같은 메서드를 통해 데이터베이스에 데이터를 저장하고 검색합니다. 이를 통해 메인 애플리케이션 코드는 데이터베이스 구현 세부 사항에 직접적으로 의존하지 않습니다.\n\n### 패턴 2: 어댑터 (Adapter)\n- **타입**: 구조적\n- **위치**: `core/util/tree_sitter.py`\n- **목적**: 외부 라이브러리(Tree-sitter)의 인터페이스를 애플리케이션에서 예상하는 인터페이스로 변환합니다.\n- **구현**: `tree_sitter.py` 모듈은 Tree-sitter C++ 라이브러리를 Python 코드로 래핑하여 사용하기 쉽게 만듭니다. `parse_code` 함수는 Tree-sitter 파서를 호출하고 AST를 생성하여 애플리케이션에서 사용할 수 있도록 변환합니다.\n\n### 패턴 3: 파이프라인 (Pipeline)\n- **타입**: 행동적\n- **위치**: 코드 청킹 프로세스 (Pass 1, Pass 2)\n- **목적**: 일련의 처리 단계를 통해 데이터를 처리합니다. 각 단계는 특정 작업을 수행하며, 이전 단계의 출력을 입력으로 받습니다.\n- **구현**: 코드 청킹 프로세스는 파일 타입 확인, Tree-sitter 파싱, 스마트 축소, 메타데이터 추출, 임베딩 생성 및 저장과 같은 여러 단계를 거칩니다. 각 단계는 독립적으로 수행되며, 데이터는 한 단계에서 다음 단계로 전달됩니다.\n\n## 주요 기능 아키텍처\n\n### 기능 1: 코드 인덱싱\n\n#### 아키텍처\n코드 인덱싱은 주어진 디렉토리의 소스 코드를 분석하고, 청크로 분할하고, 임베딩을 생성하여 PostgreSQL + pgvector 데이터베이스에 저장하는 기능입니다. 이 기능은 2-Pass 프로세스를 따릅니다: 1) 단일 파일 분석, 2) 크로스 파일 분석.\n\n#### 흐름 다이어그램\n```mermaid\ngraph LR\n    A[디렉토리 경로 입력] --> B(파일 목록 생성);\n    B --> C{파일 타입 확인};\n    C -- 코드 파일 --> D(Tree-sitter 파싱);\n    C -- 비코드 파일 --> E(기본 청킹);\n    D --> F(스마트 축소);\n    E --> F;\n    F --> G(메타데이터 추출);\n    G --> H(임베딩 생성);\n    H --> I[PostgreSQL + pgvector 저장];\n    I --> J{크로스 파일 분석 (Pass 2)};\n    J -- 필요 --> K(심볼 맵 구축);\n    K --> L(참조 관계 분석);\n    L --> M(업데이트된 메타데이터 저장);\n    style A fill:#f9f,stroke:#333,stroke-width:2px\n    style I fill:#ccf,stroke:#333,stroke-width:2px\n```\n\n#### 핵심 구성 요소\n- `main.py`: 메인 실행 파일로, 디렉토리 경로를 입력받아 인덱싱 프로세스를 시작합니다.\n- `PgVectorIndex`: 파일 청킹, 임베딩 생성, 데이터베이스 저장 로직을 포함합니다.\n- `tree_sitter.py`: Tree-sitter 파싱을 위한 유틸리티 함수를 제공합니다.\n- `embeddings_provider.py`: 임베딩 모델을 관리하고 임베딩을 생성합니다.\n\n### 기능 2: 코드 검색\n\n#### 아키텍처\n코드 검색은 주어진 쿼리에 대한 관련 코드 청크를 PostgreSQL + pgvector 데이터베이스에서 검색하는 기능입니다.\n\n#### 흐름 다이어그램\n```mermaid\ngraph LR\n    A[검색 쿼리 입력] --> B(임베딩 생성);\n    B --> C(벡터 검색);\n    C --> D[PostgreSQL + pgvector];\n    D --> E(검색 결과 반환);\n    style A fill:#f9f,stroke:#333,stroke-width:2px\n    style D fill:#ccf,stroke:#333,stroke-width:2px\n```\n\n#### 핵심 구성 요소\n- `PgVectorIndex`: 벡터 검색 쿼리를 실행하고 결과를 반환합니다.\n- `embeddings_provider.py`: 검색 쿼리의 임베딩을 생성합니다.\n- `db_test.py`: 검색 기능을 테스트하는 스크립트입니다.\n\n## 아키텍처 고려 사항\n\n### 확장성\n- PostgreSQL + pgvector는 대규모 데이터셋을 처리할 수 있도록 설계되었으며, 필요에 따라 확장할 수 있습니다.\n- 비동기 처리를 통해 I/O 바운드 작업의 병렬성을 높여 성능을 향상시킬 수 있습니다.\n\n### 유지보수성\n- 모듈화된 구조는 코드의 가독성과 유지보수성을 향상시킵니다.\n- 명확하게 정의된 인터페이스와 디자인 패턴은 코드의 재사용성을 높이고 변경에 대한 영향을 줄입니다.\n\n### 확장성\n- 어댑터 패턴을 사용하여 새로운 언어 또는 데이터 저장소를 쉽게 통합할 수 있습니다.\n- 파이프라인 패턴을 사용하여 코드 청킹 프로세스에 새로운 단계를 추가하거나 기존 단계를 수정할 수 있습니다.\n",
  "metadata": {
    "description": "주요 기능에서 사용되는 시스템 아키텍처 및 디자인 패턴 (아키텍처 다이어그램 및 플로우 다이어그램 포함)"
  },
  "created_at": "2025-10-15T18:25:18.781563",
  "content_hash": "8d2ee40c8905c37eec78e83bddbe01caa5d086f5a239804ef53970fd53d422c8"
}