{
  "page_type": "architecture",
  "page_title": "전체 시스템 아키텍처 및 주요 기능에서 사용되는 디자인 패턴 (아키텍처 다이어그램 & 모듈 다이어그램 & 플로우 다이어그램 포함)",
  "content": "# 전체 시스템 아키텍처 및 디자인 패턴\n\n## 시스템 아키텍처 개요\n\n### 아키텍처 스타일\n이 프로젝트는 **모듈형 파이프라인 아키텍처 (Modular Pipeline Architecture)** 스타일을 채택하고 있습니다. 소스 코드 청킹 및 인덱싱이라는 복잡한 작업을 여러 독립적인 단계와 모듈로 분리하여 처리합니다. 각 모듈은 특정 책임을 가지며, 데이터는 이들 모듈을 통해 순차적으로 흐르면서 처리됩니다. 이는 특히 \"Pass 1: 단일 파일 분석\"과 \"Pass 2: 크로스 파일 분석\"으로 명확하게 구분되는 청킹 프로세스에서 두드러집니다.\n\n주요 특징은 다음과 같습니다:\n*   **컴포넌트 기반**: 파싱, 청킹, 임베딩, 인덱싱, 저장소 관리 등 명확하게 정의된 컴포넌트들이 존재합니다.\n*   **파이프라인 처리**: 코드 파일이 시스템에 입력되면, 파싱 -> 청킹 -> 메타데이터 추출 -> 임베딩 -> 저장소 저장의 일련의 단계를 거칩니다.\n*   **확장성 및 교체 가능성**: 임베딩 프로바이더나 인덱싱 백엔드(PgVector, LanceDB)와 같은 핵심 컴포넌트들은 추상화되어 있어, 필요에 따라 다른 구현체로 쉽게 교체하거나 확장할 수 있습니다.\n*   **데이터 중심**: 모든 처리 과정은 코드 청크와 그 메타데이터를 중심으로 이루어지며, PostgreSQL의 `pgvector`와 `JSONB`를 활용하여 구조화된 데이터와 유연한 메타데이터를 함께 관리합니다.\n\n### 주요 아키텍처 결정 및 근거\n1.  **Tree-sitter 기반 파싱 채택**:\n    *   **근거**: 언어에 구애받지 않는 정확하고 구조적인 AST(Abstract Syntax Tree) 파싱을 위해 C++ 기반의 Tree-sitter를 사용합니다. 이는 단순한 텍스트 분할이 아닌, 코드의 의미론적 구조를 이해하고 청킹하는 데 필수적입니다. 다양한 언어(Python, Java, JavaScript 등)를 일관된 방식으로 처리할 수 있게 합니다.\n2.  **2-Pass 청킹 프로세스 도입**:\n    *   **근거**: 단일 파일 내의 구조적 청킹(Pass 1)과 파일 간의 관계 분석(Pass 2)을 분리하여 처리합니다. Pass 1에서 기본적인 청크와 메타데이터를 생성하고, Pass 2에서 전체 프로젝트의 심볼 맵을 구축하여 `referenced_by`, `subclasses`, `dependencies` 등 복잡한 크로스 파일 관계를 분석하고 메타데이터를 업데이트합니다. 이는 복잡한 관계 분석을 효율적으로 수행하고, 초기 청킹 단계의 부담을 줄입니다.\n3.  **플러그형 임베딩 및 인덱싱 백엔드**:\n    *   **근거**: `EmbeddingsProvider`와 `PgVectorIndex`/`LanceDBIndex`와 같은 추상화를 통해 특정 임베딩 모델이나 데이터베이스 기술에 종속되지 않도록 합니다. 이를 통해 향후 더 나은 임베딩 모델이나 다른 벡터 데이터베이스로의 전환이 용이하며, 시스템의 유연성과 확장성을 높입니다.\n4.  **PostgreSQL + pgvector 및 JSONB 활용**:\n    *   **근거**: `pgvector`는 벡터 임베딩의 효율적인 저장 및 유사도 검색을 제공하며, `JSONB`는 코드 청크의 풍부하고 유연한 메타데이터(심볼, 임포트, 참조 관계 등)를 스키마 없이 저장할 수 있게 합니다. 이는 코드의 복잡한 속성을 효과적으로 캡처하고 검색하는 데 유리합니다.\n5.  **Python으로 포팅 및 비동기 처리**:\n    *   **근거**: 원본 TypeScript 프로젝트의 로직과 구조를 Python으로 이식하여 기존의 검증된 청킹 로직을 활용합니다. `asyncio`를 사용하여 I/O 바운드 작업(DB 접근, 임베딩 생성)의 성능을 향상시키고, 동시성을 확보합니다.\n\n### 컴포넌트 개요\n*   **Tree-sitter 파서 (`vendor/`, `core/util/tree_sitter.py`)**: C++ 기반의 Tree-sitter 라이브러리를 Python에서 사용할 수 있도록 래핑하고, 특정 언어(Python, Java, JavaScript)의 파서를 로드 및 관리합니다. 소스 코드를 AST로 파싱하는 핵심 역할을 담당합니다.\n*   **청킹 모듈 (`core/indexing/chunk/`)**:\n    *   `code.py`: Tree-sitter AST를 기반으로 코드 파일을 구조적으로 청킹하는 스마트 청킹 로직을 구현합니다. 클래스, 함수, 메서드 단위로 청크를 생성하고 메타데이터를 추출합니다.\n    *   `basic.py`: 코드 파일이 아닌 일반 텍스트 파일에 대한 기본 청킹 전략을 제공합니다.\n    *   `chunk.py`: 청킹 전략을 조정하고, 토큰 제한 등을 관리합니다.\n    *   `metadata.py`: 청크에서 심볼, 임포트, 참조 관계 등 다양한 메타데이터를 추출하고 관리합니다.\n*   **임베딩 프로바이더 (`core/embeddings/embeddings_provider.py`)**: 텍스트 청크를 벡터 임베딩으로 변환하는 역할을 담당합니다. `sentence-transformers`와 같은 외부 라이브러리를 추상화하여 사용합니다.\n*   **인덱싱 백엔드 (`core/indexing/pgvector_index.py`, `core/indexing/lance_db_index.py`)**:\n    *   `PgVectorIndex`: PostgreSQL 및 `pgvector`를 사용하여 청크, 메타데이터, 임베딩을 저장하고 검색하는 구체적인 구현체입니다. 데이터베이스와의 상호작용을 캡슐화합니다.\n    *   `LanceDBIndex`: (README에는 언급되었으나, 코드 구조상 `pgvector_index.py`가 주요 구현체로 보임) 다른 벡터 데이터베이스 백엔드를 위한 대안적인 인덱싱 구현체입니다.\n*   **LLM 유틸리티 (`core/llm/count_tokens.py`)**: 텍스트의 토큰 수를 계산하여 청크 크기 제한 등을 관리하는 데 사용됩니다.\n*   **메인 애플리케이션 (`main.py`)**: 전체 시스템의 진입점입니다. 특정 디렉토리의 파일을 스캔하고, 청킹 및 인덱싱 프로세스를 오케스트레이션합니다.\n*   **설정 스크립트 (`setup_vendor.py`, `build_parsers.py`)**: Tree-sitter 파서 소스를 다운로드하고 컴파일하여 시스템이 사용할 수 있도록 준비합니다.\n*   **데이터베이스 (`PostgreSQL + pgvector`)**: 청크, 메타데이터, 임베딩 벡터를 영구적으로 저장하는 외부 데이터베이스 시스템입니다.\n\n## 아키텍처 다이어그램\n\n### 고수준 아키텍처\n```mermaid\ngraph TD\n    subgraph \"외부 시스템\"\n        A[\"소스 코드 파일\"] --> B(\"Tree-sitter 파서\")\n        C[\"PostgreSQL + pgvector\"]\n    end\n\n    subgraph \"Python 청킹 시스템\"\n        D[\"메인 애플리케이션 (main.py)\"]\n        E[\"청킹 모듈\"]\n        F[\"임베딩 프로바이더\"]\n        G[\"인덱싱 백엔드\"]\n    end\n\n    A --> D\n    D --> E\n    E --> B\n    E --> F\n    F --> G\n    G --> C\n    C --> G\n    G --> D\n```\n\n### 컴포넌트 상호작용\n```mermaid\nsequenceDiagram\n    participant User\n    participant MainApp as main.py\n    participant Index as PgVectorIndex\n    participant EmbedProvider as EmbeddingsProvider\n    participant ChunkModule as core/indexing/chunk/code.py\n    participant TreeSitter as core/util/tree_sitter.py\n    participant DB as PostgreSQL/pgvector\n\n    User->>MainApp: 디렉토리 인덱싱 시작 (e.g., python main.py ./test_files)\n    MainApp->>Index: 초기화 (initialize())\n    Index->>DB: DB 연결 및 테이블 확인\n    DB-->>Index: 연결 성공\n    MainApp->>MainApp: 파일 목록 스캔\n    loop 각 파일에 대해\n        MainApp->>Index: 파일 청크 가져오기 (get_chunks(file_item, content))\n        Index->>ChunkModule: 코드 청킹 요청 (getSmartCollapsedChunks(content, lang))\n        ChunkModule->>TreeSitter: AST 파싱 요청 (parse_code(content, lang))\n        TreeSitter-->>ChunkModule: AST 반환\n        ChunkModule-->>Index: 청크 목록 및 메타데이터 반환\n        Index->>EmbedProvider: 청크 임베딩 요청 (get_embeddings(chunks))\n        EmbedProvider-->>Index: 임베딩 벡터 반환\n        Index->>DB: 청크 및 임베딩 저장 (INSERT INTO chunks ...)\n        DB-->>Index: 저장 완료\n    end\n    MainApp->>Index: 크로스 파일 분석 (Pass 2 - 개념적)\n    Index->>DB: 기존 청크 검색 (SELECT * FROM chunks)\n    DB-->>Index: 청크 데이터 반환\n    Index->>Index: 심볼 맵 구축 및 관계 분석\n    Index->>DB: 메타데이터 업데이트 (UPDATE chunks SET metadata = ...)\n    DB-->>Index: 업데이트 완료\n\n    User->>MainApp: 검색 요청 (e.g., python db_test.py)\n    MainApp->>Index: 검색 (retrieve(\"query\", filters))\n    Index->>EmbedProvider: 쿼리 임베딩 요청\n    EmbedProvider-->>Index: 쿼리 임베딩 벡터 반환\n    Index->>DB: 유사도 검색 (SELECT ... ORDER BY embedding <-> query_embedding)\n    DB-->>Index: 검색 결과 반환\n    Index-->>MainApp: 검색 결과 반환\n    MainApp-->>User: 결과 출력\n```\n\n### 모듈 의존성\n```mermaid\ngraph TD\n    subgraph \"루트\"\n        A[main.py]\n        B[db_test.py]\n        C[drop_table.py]\n        D[setup_vendor.py]\n        E[build_parsers.py]\n    end\n\n    subgraph \"core/\"\n        F[core/index.py]\n        G[core/embeddings/embeddings_provider.py]\n        H[core/embeddings/simple_embeddings.py]\n        I[core/indexing/pgvector_index.py]\n        J[core/indexing/lance_db_index.py]\n        K[core/indexing/chunk/chunk.py]\n        L[core/indexing/chunk/basic.py]\n        M[core/indexing/chunk/code.py]\n        N[core/indexing/chunk/metadata.py]\n        O[core/llm/count_tokens.py]\n        P[core/util/tree_sitter.py]\n        Q[core/util/uri.py]\n    end\n\n    A --> F\n    A --> G\n    A --> I\n    A --> P\n    B --> G\n    B --> I\n    C --> I\n\n    I --> F\n    I --> G\n    I --> K\n    I --> O\n    I --> Q\n\n    G --> H\n\n    K --> L\n    K --> M\n    K --> N\n    K --> O\n\n    M --> P\n    M --> N\n    M --> O\n\n    N --> P\n    N --> Q\n\n    P --> Q\n```\n\n## 디자인 패턴\n\n### 1. 전략 패턴 (Strategy Pattern)\n*   **유형**: 행동 (Behavioral)\n*   **위치**:\n    *   `core/embeddings/embeddings_provider.py` 및 잠재적 구현체\n    *   `core/indexing/pgvector_index.py` 및 `core/indexing/lance_db_index.py`\n*   **목적**: 동일한 작업을 수행하는 여러 알고리즘(전략)을 캡슐화하고, 클라이언트가 런타임에 사용할 전략을 선택할 수 있도록 합니다. 이를 통해 시스템의 유연성과 확장성을 높입니다.\n*   **구현**:\n    *   **임베딩**: `EmbeddingsProvider` 클래스는 임베딩을 생성하는 추상화된 인터페이스 역할을 합니다. `simple_embeddings.py`는 `sentence-transformers`를 사용하여 실제 임베딩을 생성하는 구체적인 전략 구현으로 볼 수 있습니다. `EmbeddingsProvider`는 내부적으로 이 전략을 사용하거나, 다른 임베딩 모델로 쉽게 교체될 수 있는 구조를 가집니다.\n    *   **인덱싱**: `PgVectorIndex`와 `LanceDBIndex`는 각각 PostgreSQL/pgvector와 LanceDB라는 다른 데이터베이스 백엔드를 사용하여 청크를 저장하고 검색하는 구체적인 전략입니다. `main.py`와 같은 클라이언트는 `Index` 인터페이스(개념적)를 통해 이들 전략 중 하나를 선택하여 사용할 수 있습니다.\n\n### 2. 파사드 패턴 (Facade Pattern)\n*   **유형**: 구조 (Structural)\n*   **위치**: `core/indexing/pgvector_index.py`\n*   **목적**: 서브시스템의 복잡성을 숨기고, 클라이언트에게 서브시스템에 대한 단순화된 인터페이스를 제공합니다.\n*   **구현**: `PgVectorIndex` 클래스는 청킹, 임베딩 생성, 데이터베이스 저장 및 검색이라는 여러 복잡한 서브시스템 작업을 하나의 통일된 인터페이스(`get_chunks`, `get_get_embeddings`, `insert_chunks`, `retrieve`)로 제공합니다. `main.py`와 같은 클라이언트는 `PgVectorIndex`를 통해 이 모든 작업을 수행하며, 내부적으로 Tree-sitter 파싱, 토큰 카운팅, `sentence-transformers` 호출, SQL 쿼리 실행 등의 복잡한 세부 사항을 알 필요가 없습니다.\n\n### 3. 리포지토리 패턴 (Repository Pattern)\n*   **유형**: 구조 (Structural)\n*   **위치**: `core/indexing/pgvector_index.py`\n*   **목적**: 도메인 객체(여기서는 코드 청크)의 영속성(persistence) 로직을 추상화하여, 애플리케이션의 나머지 부분에서 데이터 저장소에 대한 직접적인 의존성을 제거합니다.\n*   **구현**: `PgVectorIndex`는 `chunks` 테이블에 대한 컬렉션처럼 동작합니다. `insert_chunks`, `retrieve`와 같은 메서드를 통해 청크 객체를 저장하고 검색하는 작업을 수행하며, 실제 데이터베이스(PostgreSQL)와의 상호작용(SQL 쿼리 생성 및 실행)은 `PgVectorIndex` 내부에 캡슐화됩니다. 이는 도메인 모델과 데이터 접근 계층을 분리하여 코드의 응집도를 높이고 테스트를 용이하게 합니다.\n\n## 주요 기능 아키텍처\n\n### 기능 1: 코드 청킹 및 인덱싱 (Pass 1: 단일 파일 분석)\n\n#### 아키텍처\n이 기능은 단일 소스 코드 파일을 입력받아, 그 내용을 구조적으로 분석하고, 의미 있는 청크로 분할하며, 각 청크에 대한 메타데이터와 벡터 임베딩을 생성하여 데이터베이스에 저장하는 과정입니다. Tree-sitter를 활용한 언어별 파싱이 핵심입니다.\n\n#### 흐름 다이어그램\n```mermaid\ngraph TD\n    A[\"소스 코드 파일 입력\"] --> B{\"파일 타입 확인\"}\n    B -- \"코드 파일\" --> C[\"Tree-sitter 파싱 (AST 생성)\"]\n    B -- \"비코드 파일\" --> D[\"기본 청킹 (토큰 기반)\"]\n    C --> E[\"스마트 청킹 (AST 노드 기반)\"]\n    E --> F[\"메타데이터 추출 (심볼, 임포트 등)\"]\n    D --> F\n    F --> G[\"토큰 수 검증 및 조정\"]\n    G --> H[\"청크 목록 생성\"]\n    H --> I[\"임베딩 생성 (EmbeddingsProvider)\"]\n    I --> J[\"PostgreSQL + pgvector에 청크, 메타데이터, 임베딩 저장\"]\n    J --> K[\"인덱싱 완료\"]\n```\n\n#### 핵심 컴포넌트\n*   `main.py`: 파일 스캔 및 인덱싱 프로세스 시작.\n*   `core/indexing/pgvector_index.py`: 청크 가져오기, 임베딩 생성 요청, 데이터베이스 저장 오케스트레이션.\n*   `core/indexing/chunk/code.py`: Tree-sitter AST를 사용하여 스마트 청킹 로직 구현.\n*   `core/indexing/chunk/basic.py`: 비코드 파일에 대한 기본 청킹.\n*   `core/indexing/chunk/metadata.py`: 청크에서 메타데이터 추출.\n*   `core/util/tree_sitter.py`: Tree-sitter 파서 로드 및 코드 파싱.\n*   `core/embeddings/embeddings_provider.py`: 청크 텍스트를 벡터 임베딩으로 변환.\n*   `core/llm/count_tokens.py`: 청크의 토큰 수 계산.\n*   `PostgreSQL + pgvector`: 청크 데이터의 영구 저장소.\n\n### 기능 2: 크로스 파일 분석 (Pass 2)\n\n#### 아키텍처\n이 기능은 Pass 1에서 저장된 모든 청크 데이터를 기반으로, 프로젝트 내의 파일 간 복잡한 관계(예: `referenced_by`, `subclasses`, `dependencies`, `dependents`)를 분석하고, 이 정보를 기존 청크의 메타데이터에 업데이트하는 과정입니다. 이는 전체 코드베이스에 대한 심층적인 이해를 가능하게 합니다.\n\n#### 흐름 다이어그램\n```mermaid\ngraph TD\n    A[\"Pass 1 완료된 청크 데이터\"] --> B[\"모든 청크 데이터 검색 (PgVectorIndex)\"]\n    B --> C[\"전역 심볼 맵 구축\"]\n    C --> D[\"각 청크에 대해 관계 분석\"]\n    D -- \"누가 나를 참조하는가\" --> D1[\"referenced_by 분석\"]\n    D -- \"누가 나를 상속하는가\" --> D2[\"subclasses 분석\"]\n    D -- \"내가 의존하는 파일\" --> D3[\"dependencies 분석\"]\n    D -- \"누가 나를 의존하는가\" --> D4[\"dependents 분석\"]\n    D1 & D2 & D3 & D4 --> E[\"업데이트된 메타데이터 생성\"]\n    E --> F[\"PostgreSQL + pgvector에 메타데이터 재저장\"]\n    F --> G[\"크로스 파일 분석 완료\"]\n```\n\n#### 핵심 컴포넌트\n*   `core/indexing/pgvector_index.py`: 기존 청크 데이터 검색 및 업데이트된 메타데이터 저장.\n*   `core/indexing/chunk/metadata.py`: (추정) 메타데이터 추출 및 업데이트 로직에 관여.\n*   (추정) 새로운 모듈 또는 `pgvector_index.py` 내부에 심볼 맵 구축 및 관계 분석 로직이 구현될 수 있음.\n*   `PostgreSQL + pgvector`: 청크 데이터 및 업데이트된 메타데이터의 영구 저장소.\n\n## 아키텍처 고려사항\n\n### 확장성 (Scalability)\n*   **병렬 처리**: `asyncio`를 사용하여 I/O 바운드 작업(DB 접근, 임베딩 생성)의 동시성을 확보하여 처리량을 늘릴 수 있습니다. 하지만 Tree-sitter 파싱과 같은 CPU 바운드 작업은 Python의 GIL(Global Interpreter Lock)로 인해 단일 프로세스 내에서 병렬화에 제한이 있을 수 있습니다.\n*   **데이터베이스**: `pgvector`는 HNSW 인덱스를 통해 대규모 벡터 데이터에 대한 효율적인 유사도 검색을 지원합니다. PostgreSQL 자체도 수평 확장을 위한 다양한 옵션(리플리카, 샤딩)을 제공합니다.\n*   **컴포넌트 교체**: 임베딩 프로바이더와 인덱싱 백엔드가 플러그형으로 설계되어, 더 고성능의 임베딩 모델이나 분산 벡터 데이터베이스(예: Milvus, Pinecone)로 쉽게 교체하여 확장성을 확보할 수 있습니다.\n*   **크로스 파일 분석**: 대규모 코드베이스의 경우 Pass 2의 심볼 맵 구축 및 관계 분석이 메모리 및 CPU 집약적일 수 있습니다. 이를 위한 최적화(예: 증분 분석, 분산 처리)가 필요할 수 있습니다.\n\n### 유지보수성 (Maintainability)\n*   **모듈성**: 파싱, 청킹, 임베딩, 인덱싱 등 각 기능이 독립적인 모듈로 분리되어 있어, 특정 기능의 변경이 다른 부분에 미치는 영향을 최소화합니다.\n*   **명확한 책임**: 각 컴포넌트와 모듈은 명확한 책임을 가지므로, 코드 이해 및 디버깅이 용이합니다.\n*   **일관된 구조**: 원본 TypeScript 프로젝트의 구조를 Python으로 포팅하여, 기존 지식을 활용하고 일관된 개발 경험을 제공합니다.\n*   **테스트 용이성**: 플러그형 컴포넌트와 추상화된 인터페이스는 단위 테스트 및 통합 테스트를 용이하게 합니다. 예를 들어, `PgVectorIndex` 대신 모의(mock) 인덱스 구현체를 사용하여 테스트할 수 있습니다.\n\n### 확장성 (Extensibility)\n*   **새로운 언어 지원**: `vendor/` 디렉토리에 새로운 Tree-sitter 파서를 추가하고, `build_parsers.py`를 통해 컴파일하며, `core/util/tree_sitter.py`에 해당 언어 로딩 로직을 추가하면 새로운 언어를 지원할 수 있습니다. `core/indexing/chunk/code.py`에서 해당 언어의 AST 구조에 맞는 청킹 로직을 추가해야 할 수도 있습니다.\n*   **새로운 임베딩 모델**: `core/embeddings/` 디렉토리에 새로운 임베딩 모델을 구현하는 클래스를 추가하고, `EmbeddingsProvider`가 이를 사용할 수 있도록 확장할 수 있습니다.\n*   **새로운 인덱싱 백엔드**: `core/indexing/`에 `PgVectorIndex`와 유사한 새로운 인덱스 클래스(예: `ElasticsearchIndex`, `PineconeIndex`)를 구현하여 다른 데이터베이스나 검색 엔진을 지원할 수 있습니다. `lance_db_index.py`가 이미 이러한 확장성을 보여주는 예시입니다.\n*   **청킹 전략 변경**: `core/indexing/chunk/` 내에 새로운 청킹 전략 모듈을 추가하거나 기존 모듈을 수정하여, 특정 요구사항에 맞는 청킹 방식을 구현할 수 있습니다.\n*   **메타데이터 확장**: `JSONB` 필드를 사용하여 청크에 저장되는 메타데이터 스키마를 유연하게 확장할 수 있습니다. 새로운 메타데이터 필드를 추가해도 기존 시스템에 큰 영향을 주지 않습니다.",
  "metadata": {
    "description": "주요 기능에서 사용되는 시스템 아키텍처 및 디자인 패턴 (아키텍처 다이어그램 & 모듈 다이어그램 & 플로우 다이어그램 포함)"
  },
  "created_at": "2025-10-19T18:45:36.965206",
  "content_hash": "6311c53513bad11175b5bfd493f8b02170341e8ba34eff25ea525309bd7b9472"
}