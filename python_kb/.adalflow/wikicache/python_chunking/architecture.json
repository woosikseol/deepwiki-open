{
  "page_type": "architecture",
  "page_title": "전체 시스템 아키텍처 및 주요 기능에서 사용되는 디자인 패턴 (아키텍처 다이어그램 & 모듈 다이어그램 & 플로우 다이어그램 포함)",
  "content": "# 전체 시스템 아키텍처 및 디자인 패턴\n\n## 시스템 아키텍처 개요\n\n### 아키텍처 스타일\n이 프로젝트는 **계층형 아키텍처(Layered Architecture)**와 **파이프라인 아키텍처(Pipeline Architecture)**의 특성을 결합하여 구현되었습니다.\n\n*   **계층형 아키텍처**: 시스템은 명확하게 정의된 계층으로 나뉘어 각 계층은 특정 역할과 책임을 가집니다. 예를 들어, 데이터 파싱 계층, 청킹 로직 계층, 임베딩 생성 계층, 데이터 저장 계층 등이 분리되어 있습니다. 각 계층은 상위 계층에 서비스를 제공하고 하위 계층의 서비스에 의존합니다. 이는 관심사의 분리를 촉진하고 시스템의 유지보수성을 높입니다.\n*   **파이프라인 아키텍처**: 코드 파일이 시스템에 입력되면, 파싱, 청킹, 메타데이터 추출, 임베딩 생성, 데이터베이스 저장, 그리고 최종적으로 교차 파일 분석이라는 일련의 단계(Pass)를 거치며 데이터가 순차적으로 처리됩니다. 각 단계는 이전 단계의 출력을 입력으로 받아 처리하고 다음 단계로 전달하는 방식으로 구성됩니다. 이는 데이터 흐름을 명확하게 하고 각 단계의 독립적인 개발 및 테스트를 용이하게 합니다.\n\n### 주요 아키텍처 결정 및 그 이유\n\n1.  **Tree-sitter 기반 구조적 파싱 채택**:\n    *   **결정**: C++ 기반의 Tree-sitter 라이브러리를 사용하여 소스 코드를 언어의 AST(Abstract Syntax Tree)로 파싱합니다.\n    *   **이유**: 기존 텍스트 기반 청킹의 한계를 극복하고, 클래스, 함수, 메서드 등 코드의 구조적 단위에 맞춰 \"스마트 청킹\"을 수행하기 위함입니다. 이는 청크의 의미론적 일관성을 높여 임베딩 및 검색 품질을 향상시킵니다. 또한, 다중 언어 지원을 용이하게 합니다.\n\n2.  **외부 벡터 데이터베이스(PostgreSQL + pgvector) 활용**:\n    *   **결정**: 청크 데이터와 임베딩 벡터를 PostgreSQL 데이터베이스와 `pgvector` 확장을 사용하여 저장합니다.\n    *   **이유**:\n        *   **확장성**: 대량의 청크 및 임베딩 데이터를 효율적으로 관리하고 유사도 검색을 수행할 수 있도록 합니다.\n        *   **분리**: 핵심 청킹 및 임베딩 로직과 데이터 영속성 계층을 분리하여 각 부분을 독립적으로 개발하고 확장할 수 있게 합니다.\n        *   **기능성**: `pgvector`의 HNSW 인덱스 등을 활용하여 고성능 벡터 유사도 검색을 제공합니다.\n\n3.  **2단계(2-Pass) 분석 프로세스 도입**:\n    *   **결정**: 청킹 및 인덱싱 과정을 \"단일 파일 분석(Pass 1)\"과 \"크로스 파일 분석(Pass 2)\"의 두 단계로 나눕니다.\n    *   **이유**:\n        *   **효율성**: Pass 1에서 개별 파일을 독립적으로 빠르게 처리하여 기본적인 청크와 메타데이터를 생성합니다.\n        *   **정확성**: Pass 2에서 전체 프로젝트의 인덱싱된 데이터를 기반으로 심볼 맵을 구축하고, `referenced_by`, `subclasses`, `dependencies` 등 파일 간의 복잡한 관계를 정확하게 분석하여 메타데이터를 보강합니다. 이는 더 풍부하고 의미 있는 검색 결과를 가능하게 합니다.\n\n4.  **Python 언어 포팅 및 C++ Tree-sitter 바인딩 활용**:\n    *   **결정**: 기존 TypeScript 프로젝트를 Python으로 포팅하되, Tree-sitter의 핵심 파싱 로직은 C++ 기반의 바인딩을 통해 직접 사용합니다.\n    *   **이유**: Python의 풍부한 생태계(예: `sentence-transformers`, `asyncio`, 데이터베이스 ORM 등)와 개발 편의성을 활용하면서도, 성능에 민감한 파싱 부분에서는 C++의 효율성을 유지하여 최적의 균형을 찾습니다.\n\n### 구성 요소 개요\n\n*   **파서 모듈 (`core/util/tree_sitter.py`, `vendor/`)**:\n    *   **책임**: 소스 코드 파일을 파싱하여 언어별 AST(Abstract Syntax Tree)를 생성합니다. `setup_vendor.py` 및 `build_parsers.py` 스크립트를 통해 C++ 기반 Tree-sitter 파서를 관리하고 컴파일합니다.\n*   **청킹 모듈 (`core/indexing/chunk/`)**:\n    *   **책임**: 파서가 생성한 AST 또는 원본 텍스트를 기반으로 코드 청크를 생성합니다. `code.py`는 Tree-sitter 기반의 스마트 청킹을, `basic.py`는 비코드 파일이나 fallback을 위한 기본 청킹을 제공합니다. `metadata.py`는 청크에서 심볼, 임포트 등 다양한 메타데이터를 추출합니다.\n*   **임베딩 모듈 (`core/embeddings/`)**:\n    *   **책임**: 생성된 텍스트 청크를 고차원 벡터 임베딩으로 변환합니다. `embeddings_provider.py`는 `sentence-transformers`와 같은 외부 라이브러리를 사용하여 임베딩 모델을 관리하고 임베딩을 생성합니다.\n*   **인덱싱/저장 모듈 (`core/indexing/`)**:\n    *   **책임**: 청크, 메타데이터, 임베딩을 데이터베이스에 저장하고 관리합니다. `pgvector_index.py`는 PostgreSQL + pgvector를 사용하여 영속성을 담당하며, 유사도 검색 기능을 제공합니다. `lance_db_index.py`는 다른 인덱스 백엔드를 위한 확장 가능성을 보여줍니다.\n*   **LLM 유틸리티 (`core/llm/count_tokens.py`)**:\n    *   **책임**: 청크의 토큰 수를 계산하여 최대 토큰 제한을 관리합니다.\n*   **메인 애플리케이션 (`main.py`)**:\n    *   **책임**: 전체 인덱싱 프로세스를 오케스트레이션하고, CLI 입력을 처리하여 특정 디렉토리를 스캔하고 인덱싱하는 역할을 합니다.\n*   **데이터베이스 (PostgreSQL + pgvector)**:\n    *   **책임**: 모든 청크 데이터, 메타데이터, 임베딩 벡터를 영구적으로 저장하고, 벡터 유사도 검색 및 필터링 기능을 제공합니다.\n\n## 아키텍처 다이어그램\n\n### 고수준 아키텍처\n```mermaid\ngraph TD\nA[\"사용자/CLI\"] -->|코드 디렉토리 제공| B(main.py)\nB --> C;\n    C{파일 스캔 및 필터링}\nC --> D[Tree-sitter 파서]\nD --> E[청킹 로직]\nE --> F[메타데이터 추출]\nF --> G[임베딩 생성]\nG --> H[PgVector 인덱스]\nH --> I[\"PostgreSQL + pgvector DB\"]\nI --> J[크로스 파일 분석]\nJ --> H\nH --> K[검색 결과 반환]\nK --> A\n```\n\n### 구성 요소 상호작용\n```mermaid\ngraph TD\n    subgraph Application Layer\n        main.py\n    end\n\n    subgraph Core Services Layer\n        PgVectorIndex\n        EmbeddingsProvider\n        ChunkingModule[core/indexing/chunk/]\n        TreeSitterUtil[core/util/tree_sitter.py]\n        LLMUtil[core/llm/count_tokens.py]\n    end\n\n    subgraph Data Layer\n        PostgreSQL_pgvector[PostgreSQL + pgvector]\n    end\n\n    main.py -- 1. 파일 경로 & 내용 전달 --> PgVectorIndex:get_chunks()\n    PgVectorIndex:get_chunks() -- 2. 파일 타입 확인 --> ChunkingModule\n    ChunkingModule -- 3. 코드 파일? --> TreeSitterUtil:parse()\n    TreeSitterUtil:parse() -- 4. AST 반환 --> ChunkingModule:code.py\n    ChunkingModule -- 5. 청크 생성 --> PgVectorIndex\n    ChunkingModule -- 6. 메타데이터 추출 --> PgVectorIndex\n    PgVectorIndex -- 7. 토큰 계산 요청 --> LLMUtil:count_tokens()\n    PgVectorIndex -- 8. 임베딩",
  "metadata": {
    "description": "주요 기능에서 사용되는 시스템 아키텍처 및 디자인 패턴 (아키텍처 다이어그램 & 모듈 다이어그램 & 플로우 다이어그램 포함)"
  },
  "created_at": "2025-10-16T00:41:17.492851",
  "content_hash": "6159fed26678b5eb4dca061ea10857d87d061786c5ca5ca4e51f917e490a571e"
}